
lab5_168.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00000400  00000494  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000400  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000061  00800100  00800100  00000494  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000494  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000004c4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000088  00000000  00000000  00000500  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000d84  00000000  00000000  00000588  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000009c0  00000000  00000000  0000130c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000004cc  00000000  00000000  00001ccc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000164  00000000  00000000  00002198  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000047d  00000000  00000000  000022fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000002ae  00000000  00000000  00002779  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000040  00000000  00000000  00002a27  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 85 00 	jmp	0x10a	; 0x10a <__ctors_end>
   4:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
   8:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
   c:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  10:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  14:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  18:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  1c:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  20:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  24:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  28:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  2c:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  30:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  34:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  38:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  3c:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  40:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  44:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  48:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  4c:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  50:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  54:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  58:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  5c:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  60:	0c 94 b0 00 	jmp	0x160	; 0x160 <__vector_24>
  64:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  68:	ed 00       	.word	0x00ed	; ????
  6a:	c6 00       	.word	0x00c6	; ????
  6c:	c6 00       	.word	0x00c6	; ????
  6e:	c6 00       	.word	0x00c6	; ????
  70:	c6 00       	.word	0x00c6	; ????
  72:	c6 00       	.word	0x00c6	; ????
  74:	c6 00       	.word	0x00c6	; ????
  76:	c6 00       	.word	0x00c6	; ????
  78:	ed 00       	.word	0x00ed	; ????
  7a:	c6 00       	.word	0x00c6	; ????
  7c:	c6 00       	.word	0x00c6	; ????
  7e:	c6 00       	.word	0x00c6	; ????
  80:	c6 00       	.word	0x00c6	; ????
  82:	c6 00       	.word	0x00c6	; ????
  84:	c6 00       	.word	0x00c6	; ????
  86:	c6 00       	.word	0x00c6	; ????
  88:	f7 00       	.word	0x00f7	; ????
  8a:	c6 00       	.word	0x00c6	; ????
  8c:	c6 00       	.word	0x00c6	; ????
  8e:	c6 00       	.word	0x00c6	; ????
  90:	c6 00       	.word	0x00c6	; ????
  92:	c6 00       	.word	0x00c6	; ????
  94:	c6 00       	.word	0x00c6	; ????
  96:	c6 00       	.word	0x00c6	; ????
  98:	c6 00       	.word	0x00c6	; ????
  9a:	c6 00       	.word	0x00c6	; ????
  9c:	c6 00       	.word	0x00c6	; ????
  9e:	c6 00       	.word	0x00c6	; ????
  a0:	c6 00       	.word	0x00c6	; ????
  a2:	c6 00       	.word	0x00c6	; ????
  a4:	c6 00       	.word	0x00c6	; ????
  a6:	c6 00       	.word	0x00c6	; ????
  a8:	f7 00       	.word	0x00f7	; ????
  aa:	c6 00       	.word	0x00c6	; ????
  ac:	c6 00       	.word	0x00c6	; ????
  ae:	c6 00       	.word	0x00c6	; ????
  b0:	c6 00       	.word	0x00c6	; ????
  b2:	c6 00       	.word	0x00c6	; ????
  b4:	c6 00       	.word	0x00c6	; ????
  b6:	c6 00       	.word	0x00c6	; ????
  b8:	c6 00       	.word	0x00c6	; ????
  ba:	c6 00       	.word	0x00c6	; ????
  bc:	c6 00       	.word	0x00c6	; ????
  be:	c6 00       	.word	0x00c6	; ????
  c0:	c6 00       	.word	0x00c6	; ????
  c2:	c6 00       	.word	0x00c6	; ????
  c4:	c6 00       	.word	0x00c6	; ????
  c6:	c6 00       	.word	0x00c6	; ????
  c8:	0e 01       	movw	r0, r28
  ca:	c6 00       	.word	0x00c6	; ????
  cc:	c6 00       	.word	0x00c6	; ????
  ce:	c6 00       	.word	0x00c6	; ????
  d0:	c6 00       	.word	0x00c6	; ????
  d2:	c6 00       	.word	0x00c6	; ????
  d4:	c6 00       	.word	0x00c6	; ????
  d6:	c6 00       	.word	0x00c6	; ????
  d8:	12 01       	movw	r2, r4
  da:	c6 00       	.word	0x00c6	; ????
  dc:	c6 00       	.word	0x00c6	; ????
  de:	c6 00       	.word	0x00c6	; ????
  e0:	c6 00       	.word	0x00c6	; ????
  e2:	c6 00       	.word	0x00c6	; ????
  e4:	c6 00       	.word	0x00c6	; ????
  e6:	c6 00       	.word	0x00c6	; ????
  e8:	c6 00       	.word	0x00c6	; ????
  ea:	c6 00       	.word	0x00c6	; ????
  ec:	c6 00       	.word	0x00c6	; ????
  ee:	c6 00       	.word	0x00c6	; ????
  f0:	c6 00       	.word	0x00c6	; ????
  f2:	c6 00       	.word	0x00c6	; ????
  f4:	c6 00       	.word	0x00c6	; ????
  f6:	c6 00       	.word	0x00c6	; ????
  f8:	20 01       	movw	r4, r0
  fa:	c6 00       	.word	0x00c6	; ????
  fc:	c6 00       	.word	0x00c6	; ????
  fe:	c6 00       	.word	0x00c6	; ????
 100:	c6 00       	.word	0x00c6	; ????
 102:	c6 00       	.word	0x00c6	; ????
 104:	c6 00       	.word	0x00c6	; ????
 106:	c6 00       	.word	0x00c6	; ????
 108:	de 00       	.word	0x00de	; ????

0000010a <__ctors_end>:
 10a:	11 24       	eor	r1, r1
 10c:	1f be       	out	0x3f, r1	; 63
 10e:	cf ef       	ldi	r28, 0xFF	; 255
 110:	d4 e0       	ldi	r29, 0x04	; 4
 112:	de bf       	out	0x3e, r29	; 62
 114:	cd bf       	out	0x3d, r28	; 61

00000116 <__do_clear_bss>:
 116:	21 e0       	ldi	r18, 0x01	; 1
 118:	a0 e0       	ldi	r26, 0x00	; 0
 11a:	b1 e0       	ldi	r27, 0x01	; 1
 11c:	01 c0       	rjmp	.+2      	; 0x120 <.do_clear_bss_start>

0000011e <.do_clear_bss_loop>:
 11e:	1d 92       	st	X+, r1

00000120 <.do_clear_bss_start>:
 120:	a1 36       	cpi	r26, 0x61	; 97
 122:	b2 07       	cpc	r27, r18
 124:	e1 f7       	brne	.-8      	; 0x11e <.do_clear_bss_loop>
 126:	0e 94 c1 01 	call	0x382	; 0x382 <main>
 12a:	0c 94 fe 01 	jmp	0x3fc	; 0x3fc <_exit>

0000012e <__bad_interrupt>:
 12e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000132 <init_lm73_sensor>:
uint16_t uart_buf;


void init_lm73_sensor(){

	twi_start_wr(LM73_ADDRESS, 0x00, 1);		//called from twi_master.c
 132:	41 e0       	ldi	r20, 0x01	; 1
 134:	60 e0       	ldi	r22, 0x00	; 0
 136:	70 e0       	ldi	r23, 0x00	; 0
 138:	80 e9       	ldi	r24, 0x90	; 144
 13a:	0e 94 3f 01 	call	0x27e	; 0x27e <twi_start_wr>
	asm volatile("nop");	
 13e:	00 00       	nop
 140:	08 95       	ret

00000142 <read_lm73_sensor>:

	//initialize a 16-bit variable to return
	uint16_t temp_reading = 0;

	//called from twi_master.c to obtain temp reading
	twi_start_rd(LM73_ADDRESS, read_i2c_buffer, 2);
 142:	42 e0       	ldi	r20, 0x02	; 2
 144:	66 e0       	ldi	r22, 0x06	; 6
 146:	71 e0       	ldi	r23, 0x01	; 1
 148:	80 e9       	ldi	r24, 0x90	; 144
 14a:	0e 94 50 01 	call	0x2a0	; 0x2a0 <twi_start_rd>

	//stores temp reading to temp_reading
	temp_reading = read_i2c_buffer[0] << 8;
 14e:	e6 e0       	ldi	r30, 0x06	; 6
 150:	f1 e0       	ldi	r31, 0x01	; 1
 152:	80 81       	ld	r24, Z
 154:	90 e0       	ldi	r25, 0x00	; 0
 156:	98 2f       	mov	r25, r24
 158:	88 27       	eor	r24, r24
	temp_reading |= read_i2c_buffer[1];

	//returns temp_reading
	return temp_reading;
 15a:	21 81       	ldd	r18, Z+1	; 0x01

}//temp_reading
 15c:	82 2b       	or	r24, r18
 15e:	08 95       	ret

00000160 <__vector_24>:

//****************************************************************************
//This is the TWI ISR. Different actions are taken depending upon the value
//of the TWI status register TWSR.
//****************************************************************************/
ISR(TWI_vect){
 160:	1f 92       	push	r1
 162:	0f 92       	push	r0
 164:	0f b6       	in	r0, 0x3f	; 63
 166:	0f 92       	push	r0
 168:	11 24       	eor	r1, r1
 16a:	2f 93       	push	r18
 16c:	3f 93       	push	r19
 16e:	8f 93       	push	r24
 170:	9f 93       	push	r25
 172:	af 93       	push	r26
 174:	bf 93       	push	r27
 176:	ef 93       	push	r30
 178:	ff 93       	push	r31
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
 17a:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
 17e:	8e 2f       	mov	r24, r30
 180:	90 e0       	ldi	r25, 0x00	; 0
 182:	fc 01       	movw	r30, r24
 184:	38 97       	sbiw	r30, 0x08	; 8
 186:	e1 35       	cpi	r30, 0x51	; 81
 188:	f1 05       	cpc	r31, r1
 18a:	a0 f0       	brcs	.+40     	; 0x1b4 <__vector_24+0x54>
      break;      
    case TW_MT_ARB_LOST:                //Arbitration lost 
      TWCR = TWCR_START;                //initiate RESTART 
      break;
    default:                            //Error occured, save TWSR 
      twi_state = TWSR;         
 18c:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
 190:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <twi_state>
      TWCR = TWCR_RST;                  //Reset TWI, disable interupts 
 194:	84 e0       	ldi	r24, 0x04	; 4
 196:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
  }//switch
}//TWI_isr
 19a:	ff 91       	pop	r31
 19c:	ef 91       	pop	r30
 19e:	bf 91       	pop	r27
 1a0:	af 91       	pop	r26
 1a2:	9f 91       	pop	r25
 1a4:	8f 91       	pop	r24
 1a6:	3f 91       	pop	r19
 1a8:	2f 91       	pop	r18
 1aa:	0f 90       	pop	r0
 1ac:	0f be       	out	0x3f, r0	; 63
 1ae:	0f 90       	pop	r0
 1b0:	1f 90       	pop	r1
 1b2:	18 95       	reti
//of the TWI status register TWSR.
//****************************************************************************/
ISR(TWI_vect){
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
 1b4:	ec 5c       	subi	r30, 0xCC	; 204
 1b6:	ff 4f       	sbci	r31, 0xFF	; 255
 1b8:	0c 94 f8 01 	jmp	0x3f0	; 0x3f0 <__tablejump2__>
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
      else                               {TWCR = TWCR_RNACK;} //NACK last byte 
      break; 
    case TW_MR_DATA_NACK: //Data byte was rcvd and NACK xmitted
      twi_buf[twi_buf_ptr] = TWDR;      //save last byte to buffer
 1bc:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <twi_buf_ptr.1780>
 1c0:	e0 91 09 01 	lds	r30, 0x0109	; 0x800109 <twi_buf>
 1c4:	f0 91 0a 01 	lds	r31, 0x010A	; 0x80010a <twi_buf+0x1>
 1c8:	e8 0f       	add	r30, r24
 1ca:	f1 1d       	adc	r31, r1
 1cc:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
 1d0:	80 83       	st	Z, r24
      TWCR = TWCR_STOP;                 //initiate a STOP
 1d2:	84 e9       	ldi	r24, 0x94	; 148
 1d4:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
      break;      
 1d8:	e0 cf       	rjmp	.-64     	; 0x19a <__vector_24+0x3a>
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    case TW_START:          //START has been xmitted, fall thorough
    case TW_REP_START:      //Repeated START was xmitted
      TWDR = twi_bus_addr;  //load up the twi bus address
 1da:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <twi_bus_addr>
 1de:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
      twi_buf_ptr = 0;      //initalize buffer pointer 
 1e2:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <twi_buf_ptr.1780>
      TWCR = TWCR_SEND;     //send SLA+RW
 1e6:	85 e8       	ldi	r24, 0x85	; 133
 1e8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
      break;
 1ec:	d6 cf       	rjmp	.-84     	; 0x19a <__vector_24+0x3a>
    case TW_MT_SLA_ACK:     //SLA+W was xmitted and ACK rcvd, fall through 
    case TW_MT_DATA_ACK:                //Data byte was xmitted and ACK rcvd
      if (twi_buf_ptr < twi_msg_size){  //send data till done
 1ee:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <twi_buf_ptr.1780>
 1f2:	90 91 0c 01 	lds	r25, 0x010C	; 0x80010c <twi_msg_size>
 1f6:	89 17       	cp	r24, r25
 1f8:	60 f7       	brcc	.-40     	; 0x1d2 <__vector_24+0x72>
        TWDR = twi_buf[twi_buf_ptr++];  //load next and postincrement index
 1fa:	e0 91 09 01 	lds	r30, 0x0109	; 0x800109 <twi_buf>
 1fe:	f0 91 0a 01 	lds	r31, 0x010A	; 0x80010a <twi_buf+0x1>
 202:	91 e0       	ldi	r25, 0x01	; 1
 204:	98 0f       	add	r25, r24
 206:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <twi_buf_ptr.1780>
 20a:	e8 0f       	add	r30, r24
 20c:	f1 1d       	adc	r31, r1
 20e:	80 81       	ld	r24, Z
 210:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
        TWCR = TWCR_SEND;               //send next byte 
 214:	85 e8       	ldi	r24, 0x85	; 133
 216:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 21a:	bf cf       	rjmp	.-130    	; 0x19a <__vector_24+0x3a>
    case TW_MR_DATA_NACK: //Data byte was rcvd and NACK xmitted
      twi_buf[twi_buf_ptr] = TWDR;      //save last byte to buffer
      TWCR = TWCR_STOP;                 //initiate a STOP
      break;      
    case TW_MT_ARB_LOST:                //Arbitration lost 
      TWCR = TWCR_START;                //initiate RESTART 
 21c:	85 ea       	ldi	r24, 0xA5	; 165
 21e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
      break;
 222:	bb cf       	rjmp	.-138    	; 0x19a <__vector_24+0x3a>
 224:	20 91 01 01 	lds	r18, 0x0101	; 0x800101 <twi_buf_ptr.1780>
      else{TWCR = TWCR_STOP;}           //last byte sent, send STOP 
      break;
    case TW_MR_DATA_ACK:                //Data byte has been rcvd, ACK xmitted, fall through
      twi_buf[twi_buf_ptr++] = TWDR;    //fill buffer with rcvd data
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
 228:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <twi_msg_size>
 22c:	30 e0       	ldi	r19, 0x00	; 0
 22e:	90 e0       	ldi	r25, 0x00	; 0
 230:	01 97       	sbiw	r24, 0x01	; 1
 232:	28 17       	cp	r18, r24
 234:	39 07       	cpc	r19, r25
 236:	dc f4       	brge	.+54     	; 0x26e <__vector_24+0x10e>
 238:	85 ec       	ldi	r24, 0xC5	; 197
 23a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 23e:	ad cf       	rjmp	.-166    	; 0x19a <__vector_24+0x3a>
        TWCR = TWCR_SEND;               //send next byte 
      }
      else{TWCR = TWCR_STOP;}           //last byte sent, send STOP 
      break;
    case TW_MR_DATA_ACK:                //Data byte has been rcvd, ACK xmitted, fall through
      twi_buf[twi_buf_ptr++] = TWDR;    //fill buffer with rcvd data
 240:	e0 91 09 01 	lds	r30, 0x0109	; 0x800109 <twi_buf>
 244:	f0 91 0a 01 	lds	r31, 0x010A	; 0x80010a <twi_buf+0x1>
 248:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <twi_buf_ptr.1780>
 24c:	21 e0       	ldi	r18, 0x01	; 1
 24e:	28 0f       	add	r18, r24
 250:	20 93 01 01 	sts	0x0101, r18	; 0x800101 <twi_buf_ptr.1780>
 254:	e8 0f       	add	r30, r24
 256:	f1 1d       	adc	r31, r1
 258:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
 25c:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
 25e:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <twi_msg_size>
 262:	30 e0       	ldi	r19, 0x00	; 0
 264:	90 e0       	ldi	r25, 0x00	; 0
 266:	01 97       	sbiw	r24, 0x01	; 1
 268:	28 17       	cp	r18, r24
 26a:	39 07       	cpc	r19, r25
 26c:	2c f3       	brlt	.-54     	; 0x238 <__vector_24+0xd8>
      else                               {TWCR = TWCR_RNACK;} //NACK last byte 
 26e:	85 e8       	ldi	r24, 0x85	; 133
 270:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 274:	92 cf       	rjmp	.-220    	; 0x19a <__vector_24+0x3a>

00000276 <twi_busy>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
 276:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
}
 27a:	81 70       	andi	r24, 0x01	; 1
 27c:	08 95       	ret

0000027e <twi_start_wr>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
 27e:	90 91 bc 00 	lds	r25, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
//Initiates a write transfer. Loads global variables. Sends START. ISR handles
//the rest.
//****************************************************************************
void twi_start_wr(uint8_t twi_addr, uint8_t *twi_data, uint8_t byte_cnt){

  while(twi_busy());                    //wait till TWI rdy for next xfer
 282:	90 fd       	sbrc	r25, 0
 284:	fc cf       	rjmp	.-8      	; 0x27e <twi_start_wr>
  twi_bus_addr = (twi_addr & ~TW_READ); //set twi bus address, mark as write 
 286:	8e 7f       	andi	r24, 0xFE	; 254
 288:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <twi_bus_addr>
  twi_buf = twi_data;                   //load pointer to write buffer
 28c:	70 93 0a 01 	sts	0x010A, r23	; 0x80010a <twi_buf+0x1>
 290:	60 93 09 01 	sts	0x0109, r22	; 0x800109 <twi_buf>
  twi_msg_size = byte_cnt;              //load size of xfer 
 294:	40 93 0c 01 	sts	0x010C, r20	; 0x80010c <twi_msg_size>
  TWCR = TWCR_START;                    //initiate START
 298:	85 ea       	ldi	r24, 0xA5	; 165
 29a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 29e:	08 95       	ret

000002a0 <twi_start_rd>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
 2a0:	90 91 bc 00 	lds	r25, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
//Initiates a read transfer. Loads global variables. Sends START. ISR handles
//the rest.
//****************************************************************************
void twi_start_rd(uint8_t twi_addr, uint8_t *twi_data, uint8_t byte_cnt){

  while(twi_busy());                   //wait till TWI rdy for next xfer
 2a4:	90 fd       	sbrc	r25, 0
 2a6:	fc cf       	rjmp	.-8      	; 0x2a0 <twi_start_rd>
  twi_bus_addr = (twi_addr | TW_READ); //set twi bus address, mark as read  
 2a8:	81 60       	ori	r24, 0x01	; 1
 2aa:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <twi_bus_addr>
  twi_buf = twi_data;                  //load pointer to write buffer
 2ae:	70 93 0a 01 	sts	0x010A, r23	; 0x80010a <twi_buf+0x1>
 2b2:	60 93 09 01 	sts	0x0109, r22	; 0x800109 <twi_buf>
  twi_msg_size = byte_cnt;             //load size of xfer 
 2b6:	40 93 0c 01 	sts	0x010C, r20	; 0x80010c <twi_msg_size>
  TWCR = TWCR_START;                   //initiate START
 2ba:	85 ea       	ldi	r24, 0xA5	; 165
 2bc:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 2c0:	08 95       	ret

000002c2 <init_twi>:
//10K pullups are present on the board
//for alarm clock an additional 4.7K resistor is also there for pullup
//******************************************************************************

void init_twi(){
  TWDR = 0xFF;     //release SDA, default contents
 2c2:	8f ef       	ldi	r24, 0xFF	; 255
 2c4:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
  TWSR = 0x00;     //prescaler value = 1
 2c8:	10 92 b9 00 	sts	0x00B9, r1	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
  TWBR = TWI_TWBR; //defined in twi_master.h 
 2cc:	8c e0       	ldi	r24, 0x0C	; 12
 2ce:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
 2d2:	08 95       	ret

000002d4 <lm73_temp_convert>:
//the buffer pointed to by the arguement.
//TODO:Returns what???(uint8_t)??? Probably a BUG?

//Yeah, this is for you to do! ;^)

}//lm73_temp_convert
 2d4:	08 95       	ret

000002d6 <uart_putc>:
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
 2d6:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
 2da:	95 ff       	sbrs	r25, 5
 2dc:	fc cf       	rjmp	.-8      	; 0x2d6 <uart_putc>
    UDR0 = data;    // Send data byte
 2de:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
 2e2:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
 2e6:	85 ff       	sbrs	r24, 5
 2e8:	fc cf       	rjmp	.-8      	; 0x2e2 <uart_putc+0xc>
}
 2ea:	08 95       	ret

000002ec <uart_puts>:
//                        uart_puts
// Takes a string and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts(char *str) {
    int i = 0;
    while(str[i] != '\0') { // Loop through string, sending each character
 2ec:	fc 01       	movw	r30, r24
 2ee:	20 81       	ld	r18, Z
 2f0:	22 23       	and	r18, r18
 2f2:	71 f0       	breq	.+28     	; 0x310 <uart_puts+0x24>
 2f4:	31 96       	adiw	r30, 0x01	; 1
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
 2f6:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
 2fa:	95 ff       	sbrs	r25, 5
 2fc:	fc cf       	rjmp	.-8      	; 0x2f6 <uart_puts+0xa>
    UDR0 = data;    // Send data byte
 2fe:	20 93 c6 00 	sts	0x00C6, r18	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
 302:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
 306:	95 ff       	sbrs	r25, 5
 308:	fc cf       	rjmp	.-8      	; 0x302 <uart_puts+0x16>
//                        uart_puts
// Takes a string and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts(char *str) {
    int i = 0;
    while(str[i] != '\0') { // Loop through string, sending each character
 30a:	21 91       	ld	r18, Z+
 30c:	21 11       	cpse	r18, r1
 30e:	f3 cf       	rjmp	.-26     	; 0x2f6 <uart_puts+0xa>
 310:	08 95       	ret

00000312 <uart_puts_p>:

//******************************************************************
//                        uart_puts_p
// Takes a string in flash memory and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts_p(const char *str) {
 312:	9c 01       	movw	r18, r24
    while(pgm_read_byte(str) != 0x00) { // Loop through string, sending each character
 314:	c9 01       	movw	r24, r18
 316:	f9 01       	movw	r30, r18
 318:	44 91       	lpm	r20, Z
 31a:	44 23       	and	r20, r20
 31c:	99 f0       	breq	.+38     	; 0x344 <uart_puts_p+0x32>
        uart_putc(pgm_read_byte(str++));
 31e:	2f 5f       	subi	r18, 0xFF	; 255
 320:	3f 4f       	sbci	r19, 0xFF	; 255
 322:	fc 01       	movw	r30, r24
 324:	84 91       	lpm	r24, Z
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
 326:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
 32a:	95 ff       	sbrs	r25, 5
 32c:	fc cf       	rjmp	.-8      	; 0x326 <uart_puts_p+0x14>
    UDR0 = data;    // Send data byte
 32e:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
 332:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
 336:	95 ff       	sbrs	r25, 5
 338:	fc cf       	rjmp	.-8      	; 0x332 <uart_puts_p+0x20>
//******************************************************************
//                        uart_puts_p
// Takes a string in flash memory and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts_p(const char *str) {
    while(pgm_read_byte(str) != 0x00) { // Loop through string, sending each character
 33a:	c9 01       	movw	r24, r18
 33c:	f9 01       	movw	r30, r18
 33e:	44 91       	lpm	r20, Z
 340:	41 11       	cpse	r20, r1
 342:	ed cf       	rjmp	.-38     	; 0x31e <uart_puts_p+0xc>
        uart_putc(pgm_read_byte(str++));
    }
}
 344:	08 95       	ret

00000346 <uart_init>:
//must be in place for the MAX232 chip to get data.

void uart_init(){
//rx and tx enable, receive interrupt enabled, 8 bit characters
//  UCSR0B |= (1<<RXEN0) | (1<<TXEN0) | (1<<RXCIE0);
  UCSR0B |= (1<<RXEN0) | (1<<TXEN0);  //INTERRUPS DISABLED!!!
 346:	e1 ec       	ldi	r30, 0xC1	; 193
 348:	f0 e0       	ldi	r31, 0x00	; 0
 34a:	80 81       	ld	r24, Z
 34c:	88 61       	ori	r24, 0x18	; 24
 34e:	80 83       	st	Z, r24

//  UCSR0B |= (1<<RXEN0) | (1<<TXEN0) ;
//async operation, no parity,  one stop bit, 8-bit characters
UCSR0C |= (1<<UCSZ01) | (1<<UCSZ00);
 350:	e2 ec       	ldi	r30, 0xC2	; 194
 352:	f0 e0       	ldi	r31, 0x00	; 0
 354:	80 81       	ld	r24, Z
 356:	86 60       	ori	r24, 0x06	; 6
 358:	80 83       	st	Z, r24
UBRR0H = (BAUDVALUE >>8 ); //load upper byte of the baud rate into UBRR 
 35a:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
UBRR0L =  BAUDVALUE;       //load lower byte of the baud rate into UBRR 
 35e:	87 e0       	ldi	r24, 0x07	; 7
 360:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
 364:	08 95       	ret

00000366 <uart_getc>:
//Modified to not block indefinately in the case of a lost byte
//
char uart_getc(void) {
  uint16_t timer = 0;

  while (!(UCSR0A & (1<<RXC0))) {
 366:	80 e8       	ldi	r24, 0x80	; 128
 368:	9e e3       	ldi	r25, 0x3E	; 62
 36a:	02 c0       	rjmp	.+4      	; 0x370 <uart_getc+0xa>
 36c:	01 97       	sbiw	r24, 0x01	; 1
  timer++;
  if(timer >= 16000){ return(0);}
 36e:	39 f0       	breq	.+14     	; 0x37e <uart_getc+0x18>
//Modified to not block indefinately in the case of a lost byte
//
char uart_getc(void) {
  uint16_t timer = 0;

  while (!(UCSR0A & (1<<RXC0))) {
 370:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
 374:	27 ff       	sbrs	r18, 7
 376:	fa cf       	rjmp	.-12     	; 0x36c <uart_getc+0x6>
  //what should we return if nothing comes in?
  //return the data into a global variable
  //give uart_getc the address of the variable
  //return a -1 if no data comes back.
  } // Wait for byte to arrive
  return(UDR0); //return the received data
 378:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
 37c:	08 95       	ret
char uart_getc(void) {
  uint16_t timer = 0;

  while (!(UCSR0A & (1<<RXC0))) {
  timer++;
  if(timer >= 16000){ return(0);}
 37e:	80 e0       	ldi	r24, 0x00	; 0
  //return the data into a global variable
  //give uart_getc the address of the variable
  //return a -1 if no data comes back.
  } // Wait for byte to arrive
  return(UDR0); //return the received data
}
 380:	08 95       	ret

00000382 <main>:


int main()
{
	init_twi();
 382:	0e 94 61 01 	call	0x2c2	; 0x2c2 <init_twi>
uint16_t uart_buf;


void init_lm73_sensor(){

	twi_start_wr(LM73_ADDRESS, 0x00, 1);		//called from twi_master.c
 386:	41 e0       	ldi	r20, 0x01	; 1
 388:	60 e0       	ldi	r22, 0x00	; 0
 38a:	70 e0       	ldi	r23, 0x00	; 0
 38c:	80 e9       	ldi	r24, 0x90	; 144
 38e:	0e 94 3f 01 	call	0x27e	; 0x27e <twi_start_wr>
	asm volatile("nop");	
 392:	00 00       	nop

int main()
{
	init_twi();
	init_lm73_sensor();
	uart_init();
 394:	0e 94 a3 01 	call	0x346	; 0x346 <uart_init>

	sei();
 398:	78 94       	sei
		temp = uart_getc();

		if(temp != 0x00)
			read_temp_flag = 0x01;

		if(read_temp_flag = 0x01){
 39a:	c1 e0       	ldi	r28, 0x01	; 1

	sei();

	while(1)
	{
		temp = uart_getc();
 39c:	0e 94 b3 01 	call	0x366	; 0x366 <uart_getc>
 3a0:	08 2e       	mov	r0, r24
 3a2:	00 0c       	add	r0, r0
 3a4:	99 0b       	sbc	r25, r25
 3a6:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <temp+0x1>
 3aa:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <temp>

		if(temp != 0x00)
			read_temp_flag = 0x01;

		if(read_temp_flag = 0x01){
 3ae:	c0 93 00 01 	sts	0x0100, r28	; 0x800100 <_edata>

	//initialize a 16-bit variable to return
	uint16_t temp_reading = 0;

	//called from twi_master.c to obtain temp reading
	twi_start_rd(LM73_ADDRESS, read_i2c_buffer, 2);
 3b2:	42 e0       	ldi	r20, 0x02	; 2
 3b4:	66 e0       	ldi	r22, 0x06	; 6
 3b6:	71 e0       	ldi	r23, 0x01	; 1
 3b8:	80 e9       	ldi	r24, 0x90	; 144
 3ba:	0e 94 50 01 	call	0x2a0	; 0x2a0 <twi_start_rd>

	//stores temp reading to temp_reading
	temp_reading = read_i2c_buffer[0] << 8;
 3be:	20 91 06 01 	lds	r18, 0x0106	; 0x800106 <read_i2c_buffer>
 3c2:	30 e0       	ldi	r19, 0x00	; 0
 3c4:	32 2f       	mov	r19, r18
 3c6:	22 27       	eor	r18, r18
	temp_reading |= read_i2c_buffer[1];
 3c8:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <read_i2c_buffer+0x1>
 3cc:	28 2b       	or	r18, r24

		if(temp != 0x00)
			read_temp_flag = 0x01;

		if(read_temp_flag = 0x01){
			uart_buf = read_lm73_sensor();
 3ce:	30 93 05 01 	sts	0x0105, r19	; 0x800105 <uart_buf+0x1>
 3d2:	20 93 04 01 	sts	0x0104, r18	; 0x800104 <uart_buf>
			while(!(UCSR0A & (1 << UDRE0)));
 3d6:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
 3da:	85 ff       	sbrs	r24, 5
 3dc:	fc cf       	rjmp	.-8      	; 0x3d6 <main+0x54>
			UDR0 = uart_buf;
 3de:	20 93 c6 00 	sts	0x00C6, r18	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
			while(!(UCSR0A & (1 << UDRE0)));
 3e2:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
 3e6:	85 ff       	sbrs	r24, 5
 3e8:	fc cf       	rjmp	.-8      	; 0x3e2 <main+0x60>
			read_temp_flag = 0x00;
 3ea:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <_edata>
		}	
	}
 3ee:	d6 cf       	rjmp	.-84     	; 0x39c <main+0x1a>

000003f0 <__tablejump2__>:
 3f0:	ee 0f       	add	r30, r30
 3f2:	ff 1f       	adc	r31, r31
 3f4:	05 90       	lpm	r0, Z+
 3f6:	f4 91       	lpm	r31, Z
 3f8:	e0 2d       	mov	r30, r0
 3fa:	09 94       	ijmp

000003fc <_exit>:
 3fc:	f8 94       	cli

000003fe <__stop_program>:
 3fe:	ff cf       	rjmp	.-2      	; 0x3fe <__stop_program>
